using System.Numerics;
using Robust.Client.AutoGenerated;
using Robust.Client.UserInterface.XAML;
using Content.Client.DeltaV.Arcade.S3D.Renderer;
using Content.Client.Resources;
using Content.Shared.DeltaV.Arcade.S3D;
using FancyWindow = Content.Client.UserInterface.Controls.FancyWindow;
using Robust.Client.UserInterface;
using Robust.Client.ResourceManagement;
using Robust.Client.Graphics;
using Vector3 = Robust.Shared.Maths.Vector3;

namespace Content.Client.DeltaV.Arcade.S3D.UI;

[GenerateTypedNameReferences]
public sealed partial class S3DMenu : FancyWindow
{
    [Dependency] private readonly IEntityManager _entMan = default!;
    [Dependency] private readonly IResourceCache _resourceCache = default!;

    private readonly S3DBoundUserInterface _owner;
    public S3DMenu(S3DBoundUserInterface owner)
    {
        IoCManager.InjectDependencies(this);
        RobustXamlLoader.Load(this);

        _owner = owner;

        if (_entMan.TryGetComponent<S3DArcadeComponent>(owner.Owner, out var comp))
        {
            var renderer = new S3DRenderer(_resourceCache, comp, comp.WorldMap, TextureToArray(_resourceCache.GetTexture("/Textures/DeltaV/Other/S3D/greystone.png")));
            renderer.SetSize = new Vector2(800, 600);
            renderer.CanKeyboardFocus = true;
            MainScreen.AddChild(renderer);
        }
    }
    protected override void KeyBindDown(GUIBoundKeyEventArgs args)
    {
        base.KeyBindDown(args);

        _owner.RegisterKeyPress(args.Function);
    }

    protected override void KeyBindUp(GUIBoundKeyEventArgs args)
    {
        base.KeyBindUp(args);

        _owner.UnregisterKeyPress(args.Function);
    }

    /// <summary>
    /// Texture.GetPixel is very inefficient, so I made a new data structure where you store a 2D array of RGB values. Someone should come up with a name.
    /// </summary>
    private Vector3[,] TextureToArray(Texture texture)
    {
        var img = new Vector3[64, 64];

        int x = 1;
        int y = 1;

        while (y != 64)
        {
            var color = texture.GetPixel(x, y);
            var vec = new Vector3(color.R, color.G, color.B);
            img[x - 1, y - 1] = vec;
            Logger.Error("Vector written in image " + (x - 1) + " " + (y - 1) + ": " + img[x - 1, y - 1]);
            x++;

            if (x == 64)
            {
                x = 1;
                y++;
            }
        }

        return img;
    }
}
